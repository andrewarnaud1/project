"""
Module de vérification du planning d'exécution des scénarios.

Ce module détermine si un scénario de test automatisé est autorisé à s'exécuter
à un moment donné en fonction des critères suivants :
- Gestion des jours fériés (flag_ferie)
- Respect des plages horaires définies dans le planning

L'objectif est de faire cette vérification très tôt dans le processus pour éviter
les traitements inutiles (lancement navigateur, création des fixtures, etc.).
"""

import logging
from datetime import datetime, time
from typing import Dict, List, Optional
import pytest

from src.utils.utils import contexte_actuel

try:
    from jours_feries_france import JoursFeries
    JOURS_FERIES_DISPONIBLE = True
except ImportError:
    JOURS_FERIES_DISPONIBLE = False
    logging.warning("Bibliothèque jours-feries-france non disponible. "
                   "Vérification des jours fériés désactivée.")

LOGGER = logging.getLogger(__name__)


def est_jour_ferie(date_verification: datetime) -> bool:
    """
    Vérifie si une date donnée est un jour férié en France.
    
    Args:
        date_verification (datetime): Date à vérifier
        
    Returns:
        bool: True si la date est un jour férié, False sinon
        
    Note:
        Si la bibliothèque jours-feries-france n'est pas disponible,
        retourne toujours False (pas de vérification des jours fériés).
    """
    methode_name = contexte_actuel()
    LOGGER.debug("[%s] ---- DEBUT ----", methode_name)
    
    if not JOURS_FERIES_DISPONIBLE:
        LOGGER.debug("[%s] Bibliothèque jours fériés non disponible", methode_name)
        return False
    
    try:
        # Récupérer tous les jours fériés de l'année
        jours_feries = JoursFeries.for_year(date_verification.year)
        
        # Vérifier si la date est dans la liste des jours fériés
        date_seule = date_verification.date()
        for nom_ferie, date_ferie in jours_feries.items():
            if date_ferie == date_seule:
                LOGGER.info("[%s] Jour férié détecté: %s (%s)", 
                          methode_name, nom_ferie, date_ferie)
                return True
                
        LOGGER.debug("[%s] Pas un jour férié: %s", methode_name, date_seule)
        return False
        
    except Exception as e:
        LOGGER.warning("[%s] Erreur lors de la vérification des jours fériés: %s", 
                      methode_name, e)
        return False
    finally:
        LOGGER.debug("[%s] ---- FIN ----", methode_name)


def verifier_flag_ferie(flag_ferie: Optional[bool], est_ferie: bool) -> None:
    """
    Vérifie si l'exécution est autorisée un jour férié.
    
    Args:
        flag_ferie (Optional[bool]): Flag d'autorisation des jours fériés
            - True: autorisé les jours fériés
            - False/None: interdit les jours fériés
        est_ferie (bool): True si nous sommes un jour férié
        
    Raises:
        pytest.exit(2): Si l'exécution est interdite un jour férié
    """
    methode_name = contexte_actuel()
    LOGGER.debug("[%s] ---- DEBUT ---- (flag_ferie=%s, est_ferie=%s)", 
                methode_name, flag_ferie, est_ferie)
    
    if est_ferie and flag_ferie is not True:
        message_erreur = (
            "❌ Exécution interdite : scénario non autorisé les jours fériés "
            f"(flag_ferie={flag_ferie})"
        )
        LOGGER.critical("[%s] %s", methode_name, message_erreur)
        print(message_erreur)  # Affichage immédiat pour Jenkins
        pytest.exit(2)
    
    if est_ferie and flag_ferie is True:
        LOGGER.info("[%s] ✅ Exécution autorisée un jour férié (flag_ferie=True)", 
                   methode_name)
    
    LOGGER.debug("[%s] ---- FIN ----", methode_name)


def extraire_plages_horaires_jour(planning: List[Dict], numero_jour: int) -> List[Dict]:
    """
    Extrait toutes les plages horaires définies pour un jour donné.
    
    Args:
        planning (List[Dict]): Liste des plages horaires du planning
        numero_jour (int): Numéro du jour de la semaine (1=Lundi, 7=Dimanche)
        
    Returns:
        List[Dict]: Liste des plages horaires pour le jour donné
        
    Example:
        planning = [
            {"jour": 1, "heure_debut": "07:00:00", "heure_fin": "12:00:00"},
            {"jour": 1, "heure_debut": "14:00:00", "heure_fin": "22:00:00"},
            {"jour": 2, "heure_debut": "08:00:00", "heure_fin": "18:00:00"}
        ]
        extraire_plages_horaires_jour(planning, 1) 
        # Retourne les 2 plages du lundi
    """
    methode_name = contexte_actuel()
    LOGGER.debug("[%s] ---- DEBUT ---- (jour=%s)", methode_name, numero_jour)
    
    plages_jour = []
    
    for plage in planning:
        if plage.get("jour") == numero_jour:
            plages_jour.append(plage)
            LOGGER.debug("[%s] Plage trouvée: %s-%s", 
                        methode_name, plage.get("heure_debut"), plage.get("heure_fin"))
    
    LOGGER.info("[%s] %d plage(s) horaire(s) trouvée(s) pour le jour %s", 
               methode_name, len(plages_jour), numero_jour)
    
    LOGGER.debug("[%s] ---- FIN ----", methode_name)
    return plages_jour


def valider_format_plage(plage: Dict) -> None:
    """
    Valide le format et la cohérence d'une plage horaire.
    
    Args:
        plage (Dict): Plage horaire à valider
            
    Raises:
        ValueError: Si la plage est invalide
    """
    methode_name = contexte_actuel()
    
    # Vérifier la présence des champs obligatoires
    if "heure_debut" not in plage or "heure_fin" not in plage:
        raise ValueError(f"Plage horaire incomplète: {plage}")
    
    try:
        # Valider et convertir les heures
        heure_debut = datetime.strptime(plage["heure_debut"], "%H:%M:%S").time()
        heure_fin = datetime.strptime(plage["heure_fin"], "%H:%M:%S").time()
        
        # Vérifier la cohérence temporelle
        if heure_debut >= heure_fin:
            raise ValueError(
                f"Plage horaire incohérente: début ({plage['heure_debut']}) >= "
                f"fin ({plage['heure_fin']})"
            )
            
        LOGGER.debug("[%s] Plage horaire valide: %s-%s", 
                    methode_name, plage["heure_debut"], plage["heure_fin"])
        
    except ValueError as e:
        if "time data" in str(e):
            raise ValueError(f"Format d'heure invalide dans la plage: {plage}") from e
        raise


def est_dans_plage_horaire(heure_courante: time, plage: Dict) -> bool:
    """
    Vérifie si une heure est comprise dans une plage horaire donnée.
    
    Args:
        heure_courante (time): Heure à vérifier
        plage (Dict): Plage horaire avec heure_debut et heure_fin
        
    Returns:
        bool: True si l'heure est dans la plage, False sinon
    """
    methode_name = contexte_actuel()
    
    try:
        # Valider la plage avant utilisation
        valider_format_plage(plage)
        
        heure_debut = datetime.strptime(plage["heure_debut"], "%H:%M:%S").time()
        heure_fin = datetime.strptime(plage["heure_fin"], "%H:%M:%S").time()
        
        # Vérifier si l'heure courante est dans la plage (bornes incluses)
        dans_plage = heure_debut <= heure_courante <= heure_fin
        
        LOGGER.debug("[%s] Heure %s %s dans la plage %s-%s", 
                    methode_name, heure_courante, 
                    "EST" if dans_plage else "N'EST PAS",
                    heure_debut, heure_fin)
        
        return dans_plage
        
    except ValueError as e:
        LOGGER.error("[%s] Erreur validation plage: %s", methode_name, e)
        return False


def verifier_plages_horaires(plages_jour: List[Dict], heure_courante: time) -> None:
    """
    Vérifie si l'heure courante est autorisée selon les plages horaires du jour.
    
    Args:
        plages_jour (List[Dict]): Liste des plages horaires du jour
        heure_courante (time): Heure courante à vérifier
        
    Raises:
        pytest.exit(2): Si l'heure courante n'est dans aucune plage autorisée
    """
    methode_name = contexte_actuel()
    LOGGER.debug("[%s] ---- DEBUT ---- (%d plages à vérifier)", 
                methode_name, len(plages_jour))
    
    if not plages_jour:
        message_erreur = "❌ Aucune plage horaire définie pour ce jour"
        LOGGER.critical("[%s] %s", methode_name, message_erreur)
        print(message_erreur)
        pytest.exit(2)
    
    # Vérifier chaque plage horaire du jour
    for i, plage in enumerate(plages_jour, 1):
        LOGGER.debug("[%s] Vérification plage %d/%d", methode_name, i, len(plages_jour))
        
        if est_dans_plage_horaire(heure_courante, plage):
            message_succes = (
                f"✅ Exécution autorisée dans la plage "
                f"{plage['heure_debut']}-{plage['heure_fin']}"
            )
            LOGGER.info("[%s] %s", methode_name, message_succes)
            LOGGER.debug("[%s] ---- FIN ---- (succès)", methode_name)
            return  # Sortie anticipée dès qu'une plage est valide
    
    # Aucune plage n'est valide - construire message d'erreur détaillé
    plages_str = " ".join([f"{p['heure_debut']}-{p['heure_fin']}" for p in plages_jour])
    message_erreur = (
        f"❌ Heure actuelle ({heure_courante.strftime('%H:%M:%S')}) "
        f"hors des plages autorisées: {plages_str}"
    )
    
    LOGGER.critical("[%s] %s", methode_name, message_erreur)
    print(message_erreur)  # Affichage immédiat pour Jenkins
    pytest.exit(2)


def verifier_planning_execution(donnees_scenario_api: Dict) -> None:
    """
    Fonction principale de vérification du planning d'exécution.
    
    Cette fonction effectue toutes les vérifications nécessaires pour déterminer
    si un scénario peut s'exécuter maintenant :
    1. Vérification des jours fériés
    2. Vérification des plages horaires
    
    Args:
        donnees_scenario_api (Dict): Données du scénario récupérées via l'API
            Doit contenir : flag_ferie, planning
            
    Raises:
        pytest.exit(2): Si l'exécution n'est pas autorisée
        
    Example:
        donnees_api = {
            "flag_ferie": True,
            "planning": [
                {"jour": 1, "heure_debut": "07:00:00", "heure_fin": "12:00:00"},
                {"jour": 1, "heure_debut": "14:00:00", "heure_fin": "22:00:00"}
            ]
        }
        verifier_planning_execution(donnees_api)
    """
    methode_name = contexte_actuel()
    LOGGER.info("[%s] ======== VÉRIFICATION DU PLANNING D'EXÉCUTION ========", methode_name)
    LOGGER.debug("[%s] ---- DEBUT ----", methode_name)
    
    try:
        # === ÉTAPE 1: Récupération du contexte temporel ===
        maintenant = datetime.now()
        numero_jour_semaine = maintenant.isoweekday()  # 1=Lundi, 7=Dimanche
        heure_courante = maintenant.time()
        
        LOGGER.info("[%s] Contexte temporel:", methode_name)
        LOGGER.info("[%s]   - Date/heure: %s", methode_name, maintenant.strftime("%Y-%m-%d %H:%M:%S"))
        LOGGER.info("[%s]   - Jour semaine: %s", methode_name, numero_jour_semaine)
        
        # === ÉTAPE 2: Vérification des jours fériés ===
        LOGGER.info("[%s] --- Vérification jours fériés ---", methode_name)
        est_ferie = est_jour_ferie(maintenant)
        flag_ferie = donnees_scenario_api.get("flag_ferie")
        
        LOGGER.info("[%s]   - Est férié: %s", methode_name, est_ferie)
        LOGGER.info("[%s]   - Flag férié: %s", methode_name, flag_ferie)
        
        verifier_flag_ferie(flag_ferie, est_ferie)
        
        # === ÉTAPE 3: Extraction des plages horaires ===
        LOGGER.info("[%s] --- Vérification planning horaire ---", methode_name)
        planning = donnees_scenario_api.get("planning", [])
        
        if not planning:
            message_erreur = "❌ Aucun planning défini dans les données API"
            LOGGER.critical("[%s] %s", methode_name, message_erreur)
            print(message_erreur)
            pytest.exit(2)
        
        plages_jour = extraire_plages_horaires_jour(planning, numero_jour_semaine)
        
        # === ÉTAPE 4: Vérification des plages horaires ===
        verifier_plages_horaires(plages_jour, heure_courante)
        
        # === SUCCÈS ===
        message_succes = "✅ Planning d'exécution respecté - Scénario autorisé à s'exécuter"
        LOGGER.info("[%s] %s", methode_name, message_succes)
        print(message_succes)  # Affichage immédiat pour Jenkins
        
    except Exception as e:
        if "pytest" in str(type(e)):
            # Re-lever les exceptions pytest.exit
            raise
        else:
            # Erreur inattendue
            message_erreur = f"❌ Erreur lors de la vérification du planning: {e}"
            LOGGER.critical("[%s] %s", methode_name, message_erreur)
            print(message_erreur)
            pytest.exit(2)
    
    finally:
        LOGGER.debug("[%s] ---- FIN ----", methode_name)
        LOGGER.info("[%s] ========================================================", methode_name)


def verifier_planning_execution_rapide(donnees_scenario_api: Dict) -> bool:
    """
    Version rapide de la vérification du planning (sans pytest.exit).
    
    Utile pour les tests unitaires ou les vérifications préliminaires.
    
    Args:
        donnees_scenario_api (Dict): Données du scénario récupérées via l'API
        
    Returns:
        bool: True si l'exécution est autorisée, False sinon
    """
    methode_name = contexte_actuel()
    LOGGER.debug("[%s] ---- DEBUT ---- (mode rapide)", methode_name)
    
    try:
        maintenant = datetime.now()
        numero_jour_semaine = maintenant.isoweekday()
        heure_courante = maintenant.time()
        
        # Vérification jours fériés
        est_ferie = est_jour_ferie(maintenant)
        flag_ferie = donnees_scenario_api.get("flag_ferie")
        
        if est_ferie and flag_ferie is not True:
            LOGGER.debug("[%s] Rejeté: jour férié non autorisé", methode_name)
            return False
        
        # Vérification planning
        planning = donnees_scenario_api.get("planning", [])
        if not planning:
            LOGGER.debug("[%s] Rejeté: aucun planning défini", methode_name)
            return False
        
        plages_jour = extraire_plages_horaires_jour(planning, numero_jour_semaine)
        if not plages_jour:
            LOGGER.debug("[%s] Rejeté: aucune plage pour ce jour", methode_name)
            return False
        
        # Vérifier les plages horaires
        for plage in plages_jour:
            if est_dans_plage_horaire(heure_courante, plage):
                LOGGER.debug("[%s] Autorisé dans la plage %s-%s", 
                           methode_name, plage["heure_debut"], plage["heure_fin"])
                return True
        
        LOGGER.debug("[%s] Rejeté: heure hors plages autorisées", methode_name)
        return False
        
    except Exception as e:
        LOGGER.error("[%s] Erreur lors de la vérification: %s", methode_name, e)
        return False
    
    finally:
        LOGGER.debug("[%s] ---- FIN ----", methode_name)
