â€œâ€â€
Gestionnaire des erreurs avec mÃ©canisme de retry complet.
Termine le test actuel sans enregistrer et relance de zÃ©ro.
â€œâ€â€

import re
import os
import sys
import time
import logging
import subprocess
import pytest
from playwright.sync_api import Page

from src.utils.utils import contexte_actuel
from src.utils.screenshot_manager import take_screenshot
from src.utils.timeout_checker import VerificateurTimeout

LOGGER = logging.getLogger(**name**)

def gestion_exception(execution, etape, page: Page, exception: Exception):
â€œâ€â€œGestion des exceptions avec possibilitÃ© de retry sans sauvegardeâ€â€â€
methode_name = contexte_actuel()
LOGGER.debug(â€[%s] â€“â€“ DEBUT â€“â€“â€, methode_name)

```
# VÃ©rifier si on doit faire un retry AVANT tout traitement
if should_retry_execution(execution, exception):
    LOGGER.warning("ğŸ”„ Ã‰chec dÃ©tectÃ© - Abandon du test actuel et relance de zÃ©ro")
    
    # Screenshot rapide pour debug (optionnel)
    try:
        take_screenshot(execution, etape, page, erreur=True)
    except:
        pass  # Ignorer les erreurs de screenshot
    
    # Fermer immÃ©diatement tout et relancer
    terminate_and_restart(execution, exception)
    return  # Ne jamais arriver ici mais par sÃ©curitÃ©

# Pas de retry : traitement normal de l'erreur
# URL pour le rapport
if len(execution.etapes) == 0:
    url = execution.config.get("url_initiale")
else:
    url = page.url

# Construire le commentaire d'erreur
commentaire = construire_commentaire_erreur(
    etape.etape["nom"], execution, url, exception, page
)

LOGGER.error(" %s", commentaire)
LOGGER.error(" Exception: %s", exception)

etape.finalise(execution.compteur_etape, 2, url, commentaire)
take_screenshot(execution, etape, page, erreur=True)
LOGGER.info("[%s] Appel de pytest.exit(2)", methode_name)
pytest.exit(2)
```

def should_retry_execution(execution, exception: Exception) -> bool:
â€œâ€â€
DÃ©termine si on doit abandonner le test actuel et relancer de zÃ©ro
â€œâ€â€
# VÃ©rifier si les retries sont activÃ©s
max_retries = int(os.environ.get(â€œMAX_RETRIESâ€, â€œ0â€))
if max_retries <= 0:
return False

```
# VÃ©rifier le nombre de tentatives dÃ©jÃ  effectuÃ©es
current_retry = int(os.environ.get("CURRENT_RETRY", "0"))
if current_retry >= max_retries:
    LOGGER.warning("[RETRY] Nombre maximum de tentatives atteint (%d)", max_retries)
    return False

# Conditions pour dÃ©clencher un retry
exception_str = str(exception).lower()
retry_conditions = [
    "timeout" in exception_str,
    "connection refused" in exception_str,
    "network" in exception_str,
    "502" in exception_str,  # Bad Gateway
    "503" in exception_str,  # Service Unavailable
    "504" in exception_str,  # Gateway Timeout
    "ns_error" in exception_str,  # Erreurs Firefox
    "net::" in exception_str,  # Erreurs rÃ©seau Chrome
    "browser disconnected" in exception_str,
    "page crash" in exception_str,
]

should_retry = any(retry_conditions)

if should_retry:
    LOGGER.info("[RETRY] Condition de retry dÃ©tectÃ©e: %s", exception_str[:100])
else:
    LOGGER.debug("[RETRY] Aucune condition de retry dÃ©tectÃ©e")

return should_retry
```

def terminate_and_restart(execution, exception: Exception):
â€œâ€â€
Termine immÃ©diatement le test actuel et relance de zÃ©ro
â€œâ€â€
current_retry = int(os.environ.get(â€œCURRENT_RETRYâ€, â€œ0â€))
max_retries = int(os.environ.get(â€œMAX_RETRIESâ€, â€œ0â€))
retry_delay = int(os.environ.get(â€œRETRY_DELAYâ€, â€œ10â€))

```
LOGGER.warning(
    "[RETRY] ğŸ›‘ ABANDON du test actuel - Tentative %d/%d",
    current_retry + 1,
    max_retries
)
LOGGER.warning("[RETRY] Cause: %s", str(exception)[:100])

try:
    # Fermer immÃ©diatement le navigateur pour libÃ©rer les ressources
    if hasattr(execution, 'config') and 'page' in locals():
        try:
            page.context.browser.close()
            LOGGER.info("[RETRY] Navigateur fermÃ©")
        except:
            pass
    
    # Forcer la fermeture des processus navigateur
    cleanup_browser_processes()
    
except Exception as e:
    LOGGER.warning("[RETRY] Erreur lors du nettoyage: %s", e)

# Attendre un peu pour que tout se nettoie
LOGGER.info("[RETRY] Attente de %d secondes avant relance...", retry_delay)
time.sleep(retry_delay)

# Relancer complÃ¨tement
restart_from_zero()
```

def cleanup_browser_processes():
â€œâ€â€œForce la fermeture de tous les processus navigateurâ€â€â€
processes = [â€˜firefoxâ€™, â€˜chromiumâ€™, â€˜chromeâ€™, â€˜msedgeâ€™, â€˜playwrightâ€™]

```
for process_name in processes:
    try:
        if os.name == 'nt':  # Windows
            subprocess.run(
                ['taskkill', '/F', '/IM', f'{process_name}.exe'],
                capture_output=True,
                check=False
            )
        else:  # Unix/Linux
            subprocess.run(
                ['pkill', '-f', process_name],
                capture_output=True,
                check=False
            )
    except:
        pass
```

def restart_from_zero():
â€œâ€â€
Relance complÃ¨tement lâ€™exÃ©cution dans un nouveau processus
SANS sauvegarder les rÃ©sultats du test actuel
â€œâ€â€
LOGGER.info(â€[RETRY] ğŸ”„ RELANCE COMPLÃˆTE DE ZÃ‰ROâ€)

```
try:
    # PrÃ©parer les arguments pour le nouveau processus
    original_args = sys.argv.copy()
    
    # PrÃ©parer l'environnement pour la nouvelle tentative
    env = os.environ.copy()
    current_retry = int(env.get('CURRENT_RETRY', '0')) + 1
    env['CURRENT_RETRY'] = str(current_retry)
    
    # Ajouter un identifiant unique pour cette tentative
    from datetime import datetime
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    env['EXECUTION_ID'] = f"retry_{current_retry}_{timestamp}"
    
    LOGGER.info("[RETRY] Nouvelle tentative: %d", current_retry)
    LOGGER.info("[RETRY] ID d'exÃ©cution: %s", env['EXECUTION_ID'])
    LOGGER.info("[RETRY] Commande: %s", ' '.join(original_args))
    
    # Lancer le nouveau processus
    result = subprocess.run(
        original_args,
        env=env,
        capture_output=False,  # Garder la sortie dans le terminal
    )
    
    # Sortir avec le code de retour du nouveau processus
    LOGGER.info("[RETRY] Processus terminÃ© avec le code: %d", result.returncode)
    os._exit(result.returncode)  # Sortie immÃ©diate sans cleanup Python
    
except Exception as e:
    LOGGER.error("[RETRY] Erreur lors de la relance: %s", e)
    os._exit(1)  # Sortie d'urgence
```

def construire_commentaire_erreur(
nom_etape: str, execution, url: str, exception: Exception, page: Page
) -> str:
â€œâ€â€œConstruit le commentaire dâ€™erreur en vÃ©rifiant la causeâ€â€â€

```
base_commentaire = f"KO - Etape {execution.compteur_etape} {nom_etape}"
message_exception = str(exception)

# VÃ©rifier si c'est un timeout
if est_timeout(message_exception):
    try:
        verificateur = VerificateurTimeout(execution.config)

        if verificateur.patterns_charges:
            cause_timeout = verificateur.verifier_cause_timeout(page)

            if cause_timeout:
                return f"{base_commentaire} : Timeout dÃ» Ã  une erreur - {cause_timeout}"
            else:
                message_nettoye = nettoyer_message_timeout(message_exception)
                return f"{base_commentaire} : {message_nettoye}"
        else:
            message_nettoye = nettoyer_message_timeout(message_exception)
            return f"{base_commentaire} : {message_nettoye} (Aucun fichier d'erreur disponible)"

    except Exception as e:
        LOGGER.error("[VerificateurTimeout] Erreur : %s", e)
        message_nettoye = nettoyer_message_timeout(message_exception)
        return f"{base_commentaire} : {message_nettoye} (Erreur vÃ©rification)"
else:
    message_nettoye = nettoyer_message_erreur(message_exception, execution, url)
    return f"{base_commentaire} : {message_nettoye}"
```

def est_timeout(message_exception: str) -> bool:
â€œâ€â€œVÃ©rifie si lâ€™exception est un timeoutâ€â€â€
mots_cles_timeout = [
â€œtimeoutâ€, â€œtimed outâ€, â€œexceededâ€, â€œdÃ©laiâ€, â€œdÃ©passÃ©â€,
â€œwait_forâ€, â€œwaiting forâ€, â€œattenteâ€,
]
message_minuscule = message_exception.lower()
return any(mot_cle in message_minuscule for mot_cle in mots_cles_timeout)

def nettoyer_message_timeout(message_exception: str) -> str:
â€œâ€â€œNettoie et traduit les messages de timeoutâ€â€â€
message = nettoyer_message_base(message_exception)
message = re.sub(râ€Locator.wait_for:â€, â€œAttente Ã©lÃ©ment :â€, message)
message = re.sub(râ€exceededâ€, â€œdÃ©passÃ©â€, message)
message = re.sub(râ€to be visibleâ€, â€œvisibleâ€, message)
message = re.sub(râ€Call log:.*â€, â€œâ€, message)
message = re.sub(râ€\s+â€, â€œ â€œ, message).strip()
return message

def nettoyer_message_erreur(message: str, execution, url: str) -> str:
â€œâ€â€œNettoie les messages dâ€™erreurâ€â€â€
if â€œPage.gotoâ€ in message:
return nettoyer_erreur_navigation(message, execution, url)
elif â€œLocator.wait_forâ€ in message:
return nettoyer_erreur_attente(message)
elif â€œLocator expected to be visibleâ€ in message:
return nettoyer_erreur_visibilite(message)
else:
return nettoyer_message_base(message)

def nettoyer_erreur_navigation(message: str, execution, url: str) -> str:
â€œâ€â€œNettoie les erreurs de navigationâ€â€â€
message = re.sub(râ€^Page.goto:â€, fâ€Ouverture {url} : â€œ, message)
message = re.sub(râ€Call log:.*$â€, â€œâ€, message, flags=re.DOTALL)

```
traductions = {
    "NS_ERROR_PROXY_CONNECTION_REFUSED": "Connexion au proxy refusÃ©e",
    "NS_ERROR_UNKNOWN_PROXY_HOST": "Nom d'hÃ´te du proxy introuvable",
    "NS_ERROR_CONNECTION_REFUSED": "Connexion au serveur refusÃ©e",
    "NS_ERROR_NET_TIMEOUT": "La connexion a expirÃ©",
    "NS_ERROR_UNKNOWN_HOST": "Nom d'hÃ´te introuvable",
    "SSL_ERROR_UNKNOWN": "Echec de connexion sÃ©curisÃ©e",
}

for code, traduction in traductions.items():
    message = re.sub(rf"\b{code}\b", traduction, message)

return message.strip()
```

def nettoyer_erreur_attente(message: str) -> str:
â€œâ€â€œNettoie les erreurs dâ€™attente dâ€™Ã©lÃ©mentâ€â€â€
message = re.sub(râ€^Locator.wait_for:â€, â€œAttente Ã©lÃ©ment :â€, message)
message = re.sub(râ€exceededâ€, â€œdÃ©passÃ©â€, message)
message = re.sub(râ€to be visibleâ€, â€œvisibleâ€, message)
message = re.sub(râ€Call log:.*â€, â€œâ€, message)
return message.strip()

def nettoyer_erreur_visibilite(message: str) -> str:
â€œâ€â€œNettoie les erreurs de visibilitÃ©â€â€â€
message = re.sub(râ€Locator expected to be visibleâ€, â€œÃ‰lÃ©ment attendu visibleâ€, message)
message = re.sub(râ€Actual value:â€, â€œValeur obtenue :â€, message)  
message = re.sub(râ€Call log:.*â€, â€œâ€, message)
return message.strip()

def nettoyer_message_base(message: str) -> str:
â€œâ€â€œNettoyage de base pour tous les messagesâ€â€â€
return (
message.replace(â€\nâ€, â€œ â€œ)
.replace(â€\râ€, â€œ â€œ)
.replace(â€\â€, â€œ/â€)
.replace(â€™â€â€™, â€œâ€™â€)
.strip()
)