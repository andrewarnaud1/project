‚Äú‚Äù‚Äù
initialisation.py

Module d‚Äôinitialisation s√©quentiel pour le simulateur de tests automatis√©s.
G√®re toutes les phases de d√©marrage et la logique d‚Äôinscription API.
‚Äú‚Äù‚Äù

import os
import json
import logging
import pytest
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, Tuple

from src.utils.utils import contexte_actuel
from src.utils.api import lecture_api_scenario, inscrire_resultats_api
from src.utils.planning_execution import verifier_planning_execution
from .environnement import Environnement
from .configuration import Configuration
from src.utils.constantes import ConstantesSimulateur

LOGGER = logging.getLogger(**name**)

class ErreurInitialisation(Exception):
‚Äú‚Äù‚ÄúException de base pour l‚Äôinitialisation‚Äù‚Äù‚Äù
pass

class ErreurPreAPI(ErreurInitialisation):
‚Äú‚Äù‚ÄúErreurs avant API - exit 1, pas d‚Äôinscription‚Äù‚Äù‚Äù
pass

class ErreurPostAPI(ErreurInitialisation):
‚Äú‚Äù‚ÄúErreurs apr√®s API - exit 2, inscription obligatoire avec status=3‚Äù‚Äù‚Äù
pass

class InitialisateurScenario:
‚Äú‚Äù‚Äù
Gestionnaire d‚Äôinitialisation s√©quentiel pour les sc√©narios.

```
Responsabilit√©s :
- Chargement s√©quentiel des phases d'initialisation
- Gestion des erreurs avec inscription API appropri√©e
- Retour d'une configuration compl√®te pour l'ex√©cution
"""

def __init__(self):
    """Initialise l'initialisateur"""
    self.environnement: Optional[Dict] = None
    self.config: Optional[Dict] = None
    self.donnees_api: Optional[Dict] = None
    self.phase_courante = "INITIALISATION"
    self.api_chargee_avec_succes = False
    self.date_debut = datetime.now()
    
def initialiser(self) -> Tuple[Dict, Dict]:
    """
    Lance l'initialisation s√©quentielle compl√®te.
    
    Returns:
        Tuple[Dict, Dict]: (configuration_complete, donnees_api)
        
    Raises:
        SystemExit: Avec code 1 (pr√©-API) ou 2 (post-API)
    """
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] ========== INITIALISATION SC√âNARIO ==========", methode_name)
    
    try:
        # === PHASES 1-4 : PR√â-API (pas d'inscription en cas d'erreur) ===
        self._executer_phases_pre_api()
        
        # === PHASES 5-6 : POST-API (inscription obligatoire en cas d'erreur) ===
        self._executer_phases_post_api()
        
        LOGGER.info("[%s] ‚úÖ Initialisation compl√®te r√©ussie", methode_name)
        return self.config, self.donnees_api
        
    except ErreurPreAPI as e:
        self._gerer_erreur_pre_api(e)
        pytest.exit(1)
        
    except ErreurPostAPI as e:
        self._gerer_erreur_post_api(e)
        pytest.exit(2)
        
    except Exception as e:
        # Erreur inattendue
        if self.api_chargee_avec_succes:
            self._gerer_erreur_post_api(ErreurPostAPI(f"Erreur inattendue: {e}"))
            pytest.exit(2)
        else:
            self._gerer_erreur_pre_api(ErreurPreAPI(f"Erreur inattendue: {e}"))
            pytest.exit(1)

def _executer_phases_pre_api(self):
    """Ex√©cute les phases 1-4 sans inscription API possible"""
    self._phase_1_environnement()
    self._phase_2_configuration_base()
    self._phase_3_api_lecture()
    self._phase_4_verification_planning()
    
def _executer_phases_post_api(self):
    """Ex√©cute les phases 5-6 avec inscription API obligatoire si erreur"""
    self._phase_5_configuration_finale()
    self._phase_6_repertoires()

# === PHASES PR√â-API ===

def _phase_1_environnement(self):
    """Phase 1: Chargement et validation de l'environnement"""
    self.phase_courante = "CHARGEMENT_ENVIRONNEMENT"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 1: ENVIRONNEMENT ===", methode_name)

    try:
        environnement_manager = Environnement()
        self.environnement = environnement_manager.charger_variables_environnement()
        LOGGER.info("[%s] ‚úÖ Environnement charg√©", methode_name)
        
    except Exception as e:
        raise ErreurPreAPI(f"√âchec chargement environnement: {e}") from e

def _phase_2_configuration_base(self):
    """Phase 2: Chargement de la configuration de base (pour avoir l'identifiant)"""
    self.phase_courante = "CONFIGURATION_BASE"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 2: CONFIGURATION BASE ===", methode_name)

    try:
        config_manager = Configuration(environnement=self.environnement)
        self.config = config_manager.creer_configuration()
        
        LOGGER.info("[%s] ‚úÖ Configuration de base cr√©√©e (identifiant disponible)", methode_name)
        
    except Exception as e:
        raise ErreurPreAPI(f"√âchec cr√©ation configuration de base: {e}") from e

def _phase_3_api_lecture(self):
    """Phase 3: Lecture des donn√©es API avec l'identifiant du sc√©nario"""
    self.phase_courante = "LECTURE_API"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 3: API LECTURE ===", methode_name)

    if not self.environnement.get("lecture", True):
        LOGGER.info("[%s] üìã Lecture API d√©sactiv√©e", methode_name)
        self.donnees_api = {}
        return

    # R√©cup√©rer l'identifiant depuis la configuration
    identifiant = self.config.get("identifiant")
    if not identifiant:
        raise ErreurPreAPI("Identifiant sc√©nario non trouv√© dans la configuration")

    try:
        self.donnees_api = lecture_api_scenario(
            url_base_api_injecteur=self.environnement["url_base_api_injecteur"],
            identifiant_scenario=identifiant
        )
        self.api_chargee_avec_succes = True
        LOGGER.info("[%s] ‚úÖ API charg√©e - Inscription possible d√©sormais", methode_name)
        
    except Exception as e:
        raise ErreurPreAPI(f"√âchec lecture API: {e}") from e

def _phase_4_verification_planning(self):
    """Phase 4: V√©rification du planning d'ex√©cution"""
    self.phase_courante = "VERIFICATION_PLANNING"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 4: PLANNING ===", methode_name)

    if not self.donnees_api:
        LOGGER.info("[%s] üìã Pas de donn√©es API - Planning ignor√©", methode_name)
        return

    try:
        verifier_planning_execution(self.donnees_api)
        LOGGER.info("[%s] ‚úÖ Planning respect√©", methode_name)
        
    except SystemExit:
        # Planning non respect√© - sc√©nario ne devait pas tourner
        raise ErreurPreAPI("Planning d'ex√©cution non respect√© - Sc√©nario arr√™t√© normalement")
    except Exception as e:
        raise ErreurPreAPI(f"Erreur v√©rification planning: {e}") from e

# === PHASES POST-API ===

def _phase_5_configuration_finale(self):
    """Phase 5: Finalisation de la configuration avec les donn√©es API"""
    self.phase_courante = "CONFIGURATION_FINALE"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 5: CONFIGURATION FINALE ===", methode_name)

    try:
        # Fusionner les donn√©es API dans la configuration si disponibles
        if self.donnees_api:
            # Ici tu peux ajouter la logique pour fusionner les donn√©es API
            # avec la configuration existante si n√©cessaire
            LOGGER.info("[%s] Fusion des donn√©es API avec la configuration", methode_name)
        
        LOGGER.info("[%s] ‚úÖ Configuration finalis√©e", methode_name)
        
    except Exception as e:
        raise ErreurPostAPI(f"√âchec finalisation configuration: {e}") from e

def _phase_6_repertoires(self):
    """Phase 6: Cr√©ation des r√©pertoires de sortie"""
    self.phase_courante = "CREATION_REPERTOIRES"
    methode_name = contexte_actuel(self)
    LOGGER.info("[%s] === PHASE 6: R√âPERTOIRES ===", methode_name)

    try:
        self._creer_repertoires_sortie()
        
        # Chemin sp√©cial pour les sc√©narios exadata
        if self.config["type_scenario"] == ConstantesSimulateur.TYPE_SCENARIO_EXADATA:
            self._chemin_image_exadata()
            
        LOGGER.info("[%s] ‚úÖ R√©pertoires cr√©√©s", methode_name)
        
    except Exception as e:
        # Erreur non critique - continuer avec avertissement
        LOGGER.warning("[%s] ‚ö†Ô∏è √âchec cr√©ation r√©pertoires: %s", methode_name, e)
        self.config["screenshot_dir"] = None
        self.config["report_dir"] = None

# === M√âTHODES UTILITAIRES ===

def _creer_repertoires_sortie(self):
    """Cr√©e les r√©pertoires de screenshots et rapports"""
    date_heure = self.date_debut
    date = date_heure.date()
    heure = date_heure.strftime("%H:%M:%S")

    if self.donnees_api:
        nom_app = self.donnees_api.get("application", {}).get("nom", "NO_API")
        nom_scenario = self.donnees_api.get("nom", self.config["nom_scenario"])
    else:
        nom_app = "NO_API"
        nom_scenario = self.config["nom_scenario"]

    self.config["screenshot_dir"] = (
        f"{self.config['output_path']}/screenshots/{nom_app}/{nom_scenario}/{date}/{heure}"
    )
    self.config["report_dir"] = (
        f"{self.config['output_path']}/rapports/{nom_app}/{nom_scenario}/{date}/{heure}"
    )

    Path(self.config["screenshot_dir"]).mkdir(parents=True, exist_ok=True)
    Path(self.config["report_dir"]).mkdir(parents=True, exist_ok=True)

def _chemin_image_exadata(self):
    """Ajout du chemin des images exadata si le sc√©nario est un exadata"""
    self.config["chemin_images_exadata"] = (
        f"{self.environnement.get('scenarios_path')}/scenarios_exadata/images/{self.config['nom_scenario']}"
    )

# === GESTION D'ERREURS ===

def _gerer_erreur_pre_api(self, erreur: ErreurPreAPI):
    """G√®re les erreurs de pr√©-API (pas d'inscription)"""
    methode_name = contexte_actuel(self)
    LOGGER.critical("[%s] ‚ùå ERREUR PR√â-API: %s", methode_name, erreur)
    LOGGER.critical("[%s] Phase: %s", methode_name, self.phase_courante)
    print(f"‚ùå Erreur critique en phase {self.phase_courante}: {erreur}")
    print("‚ÑπÔ∏è Aucune inscription API (erreur avant chargement API ou planning non respect√©)")

def _gerer_erreur_post_api(self, erreur: ErreurPostAPI):
    """G√®re les erreurs post-API (inscription obligatoire avec status=3)"""
    methode_name = contexte_actuel(self)
    LOGGER.critical("[%s] ‚ùå ERREUR POST-API: %s", methode_name, erreur)
    LOGGER.critical("[%s] Phase: %s", methode_name, self.phase_courante)
    print(f"‚ùå Erreur critique en phase {self.phase_courante}: {erreur}")
    
    self._inscrire_erreur_initialisation(str(erreur))

def _inscrire_erreur_initialisation(self, message_erreur: str):
    """Inscrit une erreur d'initialisation (status=3) via l'API"""
    methode_name = contexte_actuel(self)
    
    # V√©rifier si l'inscription est possible (API charg√©e + identifiant disponible)
    if not self.api_chargee_avec_succes:
        LOGGER.warning("[%s] ‚ö†Ô∏è API non charg√©e - Pas d'inscription", methode_name)
        return
        
    # V√©rifier si l'identifiant est disponible
    identifiant = self.config.get("identifiant")
    if not identifiant:
        LOGGER.warning("[%s] ‚ö†Ô∏è Identifiant sc√©nario non disponible - Pas d'inscription", methode_name)
        print("‚ÑπÔ∏è Pas d'inscription API (identifiant sc√©nario manquant)")
        return
        
    if not self.config or not self.config.get("inscription"):
        LOGGER.warning("[%s] ‚ö†Ô∏è Inscription d√©sactiv√©e", methode_name)
        return

    try:
        duree_totale = (datetime.now() - self.date_debut).total_seconds()
        
        data_erreur = {
            "identifiant": identifiant,
            "scenario": self.config.get("nom_scenario", ""),
            "date": self.date_debut.isoformat(),
            "duree": duree_totale,
            "status": 3,  # Status UNKNOWN pour erreurs d'initialisation
            "nb_scene": 0,
            "commentaire": "Erreur lors de l'initialisation du sc√©nario - Sc√©nario non lanc√©",
            "injecteur": os.getenv("HOSTNAME", "unknown"),
            "navigateur": self.config.get("navigateur", "unknown"),
            "interface_ip": "127.0.0.1",
            "status_initial": 3,
            "commentaire_initial": "Erreur lors de l'initialisation du sc√©nario - Sc√©nario non lanc√©",
            "briques": []
        }
        
        inscrire_resultats_api(
            self.config["url_base_api_injecteur"],
            data_erreur
        )
        
        LOGGER.info("[%s] ‚úÖ Erreur d'initialisation inscrite", methode_name)
        print("‚úÖ Erreur d'initialisation inscrite en base")
        
    except Exception as e:
        LOGGER.error("[%s] ‚ùå √âchec inscription: %s", methode_name, e)
        print(f"‚ùå √âchec inscription: {e}")
        
        try:
            print("üìÑ Donn√©es d'erreur:")
            print(json.dumps(data_erreur, ensure_ascii=False, indent=2))
        except:
            pass
```

# === FONCTION UTILITAIRE ===

def initialiser_scenario() -> Tuple[Dict, Dict]:
‚Äú‚Äù‚Äù
Fonction utilitaire pour initialiser un sc√©nario.

```
Returns:
    Tuple[Dict, Dict]: (configuration_complete, donnees_api)
    
Raises:
    SystemExit: En cas d'erreur d'initialisation
"""
initialisateur = InitialisateurScenario()
return initialisateur.initialiser()
```